// Copyright (C) 2025 Vince Vasta
// SPDX-License-Identifier: Apache-2.0

//! Table state types.
use anyhow::{bail, Result};
use log::info;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};

use freezeout_core::{
    crypto::{PeerId, SigningKey},
    message::{Message, SignedMessage},
    poker::{Chips, Deck, PlayerCards, TableId},
};

/// Table state shared by all players who joined the table.
#[derive(Debug)]
pub struct Table {
    state: Mutex<State>,
}

/// A message sent to player connections.
#[derive(Debug)]
pub enum TableMessage {
    /// Sends a message to a client.
    Send(Arc<SignedMessage>),
    /// Close a client connection.
    Close,
}

/// Internal table state.
#[derive(Debug)]
struct State {
    table_id: TableId,
    seats: usize,
    join_chips: Chips,
    sk: Arc<SigningKey>,
    players: Vec<Player>,
    deck: Deck,
}

/// A table player state.
#[derive(Debug)]
struct Player {
    /// The player peer id.
    player_id: PeerId,
    /// The channel to send messages to this player connection.
    table_tx: mpsc::Sender<TableMessage>,
    /// This playe nickname.
    nickname: String,
    /// This player chips.
    chips: Chips,
    /// This player cards that are visible to all other players.
    public_cards: PlayerCards,
    /// This player private cards.
    hole_cards: PlayerCards,
}

impl Table {
    /// Creates a new table with the number of seats and a signing key to sign
    /// messages generated by this table for the clients.
    pub fn new(seats: usize, sk: Arc<SigningKey>) -> Self {
        Self {
            state: Mutex::new(State {
                table_id: TableId::new_id(),
                seats,
                join_chips: Chips(1_000_000),
                sk,
                players: Vec::with_capacity(seats),
                deck: Deck::new_and_shuffled(),
            }),
        }
    }

    /// A player joins this table.
    ///
    /// Returns error if the table is full or the player has already joined.
    pub async fn join(
        &self,
        player_id: &PeerId,
        nickname: &str,
    ) -> Result<mpsc::Receiver<TableMessage>> {
        let mut state = self.state.lock().await;

        if state.players.len() == state.seats {
            bail!("Table full");
        }

        if state.players.iter().any(|p| &p.player_id == player_id) {
            bail!("Player has already joined");
        }

        // Tell all players at the table that a player joined.
        let msg = Message::PlayerJoined {
            player_id: player_id.clone(),
            nickname: nickname.to_string(),
            chips: state.join_chips,
        };
        state.broadcast(msg).await;

        let (table_tx, table_rx) = mpsc::channel(64);

        // Send a table joined confirmation to the player who joined.
        let msg = Message::TableJoined {
            table_id: state.table_id,
            chips: state.join_chips,
        };
        let smsg = Arc::new(SignedMessage::new(&state.sk, msg));
        let _ = table_tx.send(TableMessage::Send(smsg.clone())).await;

        // Send joined message for each player at the table to the new player.
        for player in &state.players {
            let msg = Message::PlayerJoined {
                player_id: player.player_id.clone(),
                nickname: player.nickname.clone(),
                chips: player.chips,
            };
            let smsg = Arc::new(SignedMessage::new(&state.sk, msg));
            let _ = table_tx.send(TableMessage::Send(smsg.clone())).await;
        }

        // Add new player to the table.
        let player = Player {
            player_id: player_id.clone(),
            table_tx,
            nickname: nickname.to_string(),
            chips: state.join_chips,
            public_cards: PlayerCards::None,
            hole_cards: PlayerCards::None,
        };

        state.players.push(player);

        info!("Player {player_id} joined the table.");

        // All players joined deal cards.
        if state.players.len() == state.seats {
            state.shuffle_and_deal().await;
        }

        Ok(table_rx)
    }

    /// A player leaves the table.
    pub async fn leave(&self, player_id: &PeerId) {
        let mut state = self.state.lock().await;

        let len_before = state.players.len();
        state.players.retain(|p| &p.player_id != player_id);

        // If the given id has been remove notify all other players.
        if state.players.len() < len_before {
            info!("Player {player_id} left the table.");

            let msg = Message::PlayerLeft(player_id.clone());
            state.broadcast(msg).await;
        }
    }

    /// Handle a message from a player.
    pub async fn handle_message(&self, msg: SignedMessage) {
        info!("Player message: {msg:?}");
    }
}

impl State {
    /// Broadcast a message to all players at the table.
    async fn broadcast(&self, msg: Message) {
        let smsg = Arc::new(SignedMessage::new(&self.sk, msg));
        for player in &self.players {
            player.send(smsg.clone()).await;
        }
    }

    /// Shuffle a new deck and deal hole cards to players.
    async fn shuffle_and_deal(&mut self) {
        self.deck = Deck::new_and_shuffled();

        for player in &mut self.players {
            player.public_cards = PlayerCards::Covered;
            player.hole_cards = PlayerCards::Cards(self.deck.deal(), self.deck.deal());
        }

        // Deal the cards to each player.
        for player in &self.players {
            if let PlayerCards::Cards(c1, c2) = player.hole_cards {
                let msg = Message::DealCards(c1, c2);
                let smsg = Arc::new(SignedMessage::new(&self.sk, msg));
                player.send(smsg.clone()).await;
            }
        }
    }
}

impl Player {
    async fn send(&self, msg: Arc<SignedMessage>) {
        let _ = self.table_tx.send(TableMessage::Send(msg)).await;
    }
}
