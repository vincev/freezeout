// Copyright (C) 2025 Vince Vasta
// SPDX-License-Identifier: Apache-2.0

//! Table state types.
use anyhow::{bail, Result};
use log::info;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};

use freezeout_core::{
    crypto::{PlayerId, SigningKey},
    message::{Message, SignedMessage},
};

/// Table state shared by all players who joined the table.
#[derive(Debug)]
pub struct Table {
    state: Mutex<State>,
}

/// A message sent to player connections.
#[derive(Debug)]
pub enum TableMessage {
    /// Sends a message to a client.
    Send(Arc<SignedMessage>),
    /// Close a client connection.
    Close,
}

/// Internal table state.
#[derive(Debug)]
struct State {
    seats: usize,
    sk: Arc<SigningKey>,
    players: Vec<Player>,
}

/// A table player state.
#[derive(Debug)]
struct Player {
    player_id: PlayerId,
    table_tx: mpsc::Sender<TableMessage>,
    nickname: String,
}

impl Table {
    /// Creates a new table with the number of seats and a signing key to sign
    /// messages generated by this table for the clients.
    pub fn new(seats: usize, sk: Arc<SigningKey>) -> Self {
        Self {
            state: Mutex::new(State {
                seats,
                sk,
                players: Vec::with_capacity(seats),
            }),
        }
    }

    /// A player joins this table.
    ///
    /// Returns error if the table is full or the player has already joined.
    pub async fn join(
        &self,
        player_id: &PlayerId,
        nickname: &str,
    ) -> Result<mpsc::Receiver<TableMessage>> {
        let mut state = self.state.lock().await;

        if state.players.len() == state.seats {
            bail!("Table full");
        }

        if state.players.iter().any(|p| &p.player_id == player_id) {
            bail!("Player has already joined");
        }

        // Tell all players at the table that a player joined.
        let msg = Message::PlayerJoined(player_id.clone());
        state.broadcast(msg).await;

        let (table_tx, table_rx) = mpsc::channel(64);

        // Tell the new player the players at the table joined.
        for player in &state.players {
            let msg = Message::PlayerJoined(player.player_id.clone());
            let smsg = Arc::new(SignedMessage::new(&state.sk, msg));
            let _ = table_tx.send(TableMessage::Send(smsg.clone())).await;
        }

        // Add new player to the table.
        state.players.push(Player {
            player_id: player_id.clone(),
            table_tx,
            nickname: nickname.to_string(),
        });

        info!("Player {player_id} joined the table.");

        Ok(table_rx)
    }

    /// A player leaves the table.
    pub async fn leave(&self, player_id: &PlayerId) {
        let mut state = self.state.lock().await;

        let len_before = state.players.len();
        state.players.retain(|p| &p.player_id != player_id);

        // If the given id has been remove notify all other players.
        if state.players.len() < len_before {
            info!("Player {player_id} left the table.");

            let msg = Message::PlayerLeft(player_id.clone());
            state.broadcast(msg).await;
        }
    }

    /// Handle a message from a player.
    pub async fn handle_message(&self, msg: SignedMessage) {
        info!("Player message: {msg:?}");
    }
}

impl State {
    /// Broadcast a message to all players at the table.
    async fn broadcast(&self, msg: Message) {
        let smsg = Arc::new(SignedMessage::new(&self.sk, msg));
        for player in &self.players {
            let _ = player.table_tx.send(TableMessage::Send(smsg.clone())).await;
        }
    }
}
